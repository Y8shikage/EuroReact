{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\F1toF\\\\OneDrive\\\\Desktop\\\\cours\\\\cours\\\\cours-project\\\\src\\\\components\\\\MetallicPaint\\\\MetallicPaint.js\",\n  _s2 = $RefreshSig$();\n/* eslint-disable react-hooks/exhaustive-deps */\nimport { useEffect, useRef, useState } from 'react';\nimport './MetallicPaint.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst defaultParams = {\n  patternScale: 2,\n  refraction: 0.015,\n  edge: 1,\n  patternBlur: 0.005,\n  liquid: 0.07,\n  speed: 0.3\n};\nexport function parseLogoImage(file) {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  return new Promise((resolve, reject) => {\n    if (!file || !ctx) {\n      reject(new Error('Invalid file or context'));\n      return;\n    }\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = function () {\n      if (file.type === 'image/svg+xml') {\n        img.width = 1000;\n        img.height = 1000;\n      }\n      const MAX_SIZE = 1000;\n      const MIN_SIZE = 500;\n      let width = img.naturalWidth;\n      let height = img.naturalHeight;\n      if (width > MAX_SIZE || height > MAX_SIZE || width < MIN_SIZE || height < MIN_SIZE) {\n        if (width > height) {\n          if (width > MAX_SIZE) {\n            height = Math.round(height * MAX_SIZE / width);\n            width = MAX_SIZE;\n          } else if (width < MIN_SIZE) {\n            height = Math.round(height * MIN_SIZE / width);\n            width = MIN_SIZE;\n          }\n        } else {\n          if (height > MAX_SIZE) {\n            width = Math.round(width * MAX_SIZE / height);\n            height = MAX_SIZE;\n          } else if (height < MIN_SIZE) {\n            width = Math.round(width * MIN_SIZE / height);\n            height = MIN_SIZE;\n          }\n        }\n      }\n      canvas.width = width;\n      canvas.height = height;\n      const shapeCanvas = document.createElement('canvas');\n      shapeCanvas.width = width;\n      shapeCanvas.height = height;\n      const shapeCtx = shapeCanvas.getContext('2d');\n      shapeCtx.drawImage(img, 0, 0, width, height);\n      const shapeImageData = shapeCtx.getImageData(0, 0, width, height);\n      const data = shapeImageData.data;\n      const shapeMask = new Array(width * height).fill(false);\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const idx4 = (y * width + x) * 4;\n          const r = data[idx4];\n          const g = data[idx4 + 1];\n          const b = data[idx4 + 2];\n          const a = data[idx4 + 3];\n          shapeMask[y * width + x] = !(r === 255 && g === 255 && b === 255 && a === 255 || a === 0);\n        }\n      }\n      function inside(x, y) {\n        if (x < 0 || x >= width || y < 0 || y >= height) return false;\n        return shapeMask[y * width + x];\n      }\n      const boundaryMask = new Array(width * height).fill(false);\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const idx = y * width + x;\n          if (!shapeMask[idx]) continue;\n          let isBoundary = false;\n          for (let ny = y - 1; ny <= y + 1 && !isBoundary; ny++) {\n            for (let nx = x - 1; nx <= x + 1 && !isBoundary; nx++) {\n              if (!inside(nx, ny)) {\n                isBoundary = true;\n              }\n            }\n          }\n          if (isBoundary) {\n            boundaryMask[idx] = true;\n          }\n        }\n      }\n      const interiorMask = new Array(width * height).fill(false);\n      for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n          const idx = y * width + x;\n          if (shapeMask[idx] && shapeMask[idx - 1] && shapeMask[idx + 1] && shapeMask[idx - width] && shapeMask[idx + width]) {\n            interiorMask[idx] = true;\n          }\n        }\n      }\n      const u = new Float32Array(width * height).fill(0);\n      const newU = new Float32Array(width * height).fill(0);\n      const C = 0.01;\n      const ITERATIONS = 300;\n      function getU(x, y, arr) {\n        if (x < 0 || x >= width || y < 0 || y >= height) return 0;\n        if (!shapeMask[y * width + x]) return 0;\n        return arr[y * width + x];\n      }\n      for (let iter = 0; iter < ITERATIONS; iter++) {\n        for (let y = 0; y < height; y++) {\n          for (let x = 0; x < width; x++) {\n            const idx = y * width + x;\n            if (!shapeMask[idx] || boundaryMask[idx]) {\n              newU[idx] = 0;\n              continue;\n            }\n            const sumN = getU(x + 1, y, u) + getU(x - 1, y, u) + getU(x, y + 1, u) + getU(x, y - 1, u);\n            newU[idx] = (C + sumN) / 4;\n          }\n        }\n        u.set(newU);\n      }\n      let maxVal = 0;\n      for (let i = 0; i < width * height; i++) {\n        if (u[i] > maxVal) maxVal = u[i];\n      }\n      const alpha = 2.0;\n      const outImg = ctx.createImageData(width, height);\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const idx = y * width + x;\n          const px = idx * 4;\n          if (!shapeMask[idx]) {\n            outImg.data[px] = 255;\n            outImg.data[px + 1] = 255;\n            outImg.data[px + 2] = 255;\n            outImg.data[px + 3] = 255;\n          } else {\n            const raw = u[idx] / maxVal;\n            const remapped = Math.pow(raw, alpha);\n            const gray = 255 * (1 - remapped);\n            outImg.data[px] = gray;\n            outImg.data[px + 1] = gray;\n            outImg.data[px + 2] = gray;\n            outImg.data[px + 3] = 255;\n          }\n        }\n      }\n      ctx.putImageData(outImg, 0, 0);\n      canvas.toBlob(blob => {\n        if (!blob) {\n          reject(new Error('Failed to create PNG blob'));\n          return;\n        }\n        resolve({\n          imageData: outImg,\n          pngBlob: blob\n        });\n      }, 'image/png');\n    };\n    img.onerror = () => reject(new Error('Failed to load image'));\n    img.src = URL.createObjectURL(file);\n  });\n}\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\nin vec2 a_position;\nout vec2 vUv;\nvoid main() {\n    vUv = .5 * (a_position + 1.);\n    gl_Position = vec4(a_position, 0.0, 1.0);\n}`;\nconst liquidFragSource = `#version 300 es\nprecision mediump float;\nin vec2 vUv;\nout vec4 fragColor;\nuniform sampler2D u_image_texture;\nuniform float u_time;\nuniform float u_ratio;\nuniform float u_img_ratio;\nuniform float u_patternScale;\nuniform float u_refraction;\nuniform float u_edge;\nuniform float u_patternBlur;\nuniform float u_liquid;\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n\nvec3 mod289(vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 permute(vec3 x) { return mod289(((x*34.)+1.)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute(permute(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2. * fract(p * C.www) - 1.;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130. * dot(m, g);\n}\n\nvec2 get_img_uv() {\n    vec2 img_uv = vUv;\n    img_uv -= .5;\n    if (u_ratio > u_img_ratio) {\n        img_uv.x = img_uv.x * u_ratio / u_img_ratio;\n    } else {\n        img_uv.y = img_uv.y * u_img_ratio / u_ratio;\n    }\n    float scale_factor = 1.;\n    img_uv *= scale_factor;\n    img_uv += .5;\n    img_uv.y = 1. - img_uv.y;\n    return img_uv;\n}\n\nvec2 rotate(vec2 uv, float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nfloat get_color_channel(float c1, float c2, float stripe_p, vec3 w, float extra_blur, float b) {\n    float ch = c2;\n    float border = 0.;\n    float blur = u_patternBlur + extra_blur;\n    ch = mix(ch, c1, smoothstep(.0, blur, stripe_p));\n    border = w[0];\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\n    b = smoothstep(.2, .8, b);\n    border = w[0] + .4 * (1. - b) * w[1];\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\n    border = w[0] + .5 * (1. - b) * w[1];\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\n    border = w[0] + w[1];\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\n    float gradient_t = (stripe_p - w[0] - w[1]) / w[2];\n    float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));\n    ch = mix(ch, gradient, smoothstep(border - blur, border + blur, stripe_p));\n    return ch;\n}\n\nfloat get_img_frame_alpha(vec2 uv, float img_frame_width) {\n    float img_frame_alpha = smoothstep(0., img_frame_width, uv.x) * smoothstep(1., 1. - img_frame_width, uv.x);\n    img_frame_alpha *= smoothstep(0., img_frame_width, uv.y) * smoothstep(1., 1. - img_frame_width, uv.y);\n    return img_frame_alpha;\n}\n\nvoid main() {\n    vec2 uv = vUv;\n    uv.y = 1. - uv.y;\n    uv.x *= u_ratio;\n    float diagonal = uv.x - uv.y;\n    float t = .001 * u_time;\n    vec2 img_uv = get_img_uv();\n    vec4 img = texture(u_image_texture, img_uv);\n    vec3 color = vec3(0.);\n    float opacity = 1.;\n    vec3 color1 = vec3(.98, 0.98, 1.);\n    vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, uv.x + uv.y));\n    float edge = img.r;\n    vec2 grad_uv = uv;\n    grad_uv -= .5;\n    float dist = length(grad_uv + vec2(0., .2 * diagonal));\n    grad_uv = rotate(grad_uv, (.25 - .2 * diagonal) * PI);\n    float bulge = pow(1.8 * dist, 1.2);\n    bulge = 1. - bulge;\n    bulge *= pow(uv.y, .3);\n    float cycle_width = u_patternScale;\n    float thin_strip_1_ratio = .12 / cycle_width * (1. - .4 * bulge);\n    float thin_strip_2_ratio = .07 / cycle_width * (1. + .4 * bulge);\n    float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);\n    float thin_strip_1_width = cycle_width * thin_strip_1_ratio;\n    float thin_strip_2_width = cycle_width * thin_strip_2_ratio;\n    opacity = 1. - smoothstep(.9 - .5 * u_edge, 1. - .5 * u_edge, edge);\n    opacity *= get_img_frame_alpha(img_uv, 0.01);\n    float noise = snoise(uv - t);\n    edge += (1. - edge) * u_liquid * noise;\n    float refr = 0.;\n    refr += (1. - bulge);\n    refr = clamp(refr, 0., 1.);\n    float dir = grad_uv.x;\n    dir += diagonal;\n    dir -= 2. * noise * diagonal * (smoothstep(0., 1., edge) * smoothstep(1., 0., edge));\n    bulge *= clamp(pow(uv.y, .1), .3, 1.);\n    dir *= (.1 + (1.1 - edge) * bulge);\n    dir *= smoothstep(1., .7, edge);\n    dir += .18 * (smoothstep(.1, .2, uv.y) * smoothstep(.4, .2, uv.y));\n    dir += .03 * (smoothstep(.1, .2, 1. - uv.y) * smoothstep(.4, .2, 1. - uv.y));\n    dir *= (.5 + .5 * pow(uv.y, 2.));\n    dir *= cycle_width;\n    dir -= t;\n    float refr_r = refr;\n    refr_r += .03 * bulge * noise;\n    float refr_b = 1.3 * refr;\n    refr_r += 5. * (smoothstep(-.1, .2, uv.y) * smoothstep(.5, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(1., .4, bulge));\n    refr_r -= diagonal;\n    refr_b += (smoothstep(0., .4, uv.y) * smoothstep(.8, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(.8, .4, bulge));\n    refr_b -= .2 * edge;\n    refr_r *= u_refraction;\n    refr_b *= u_refraction;\n    vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);\n    w[1] -= .02 * smoothstep(.0, 1., edge + bulge);\n    float stripe_r = mod(dir + refr_r, 1.);\n    float r = get_color_channel(color1.r, color2.r, stripe_r, w, 0.02 + .03 * u_refraction * bulge, bulge);\n    float stripe_g = mod(dir, 1.);\n    float g = get_color_channel(color1.g, color2.g, stripe_g, w, 0.01 / (1. - diagonal), bulge);\n    float stripe_b = mod(dir - refr_b, 1.);\n    float b = get_color_channel(color1.b, color2.b, stripe_b, w, .01, bulge);\n    color = vec3(r, g, b);\n    color *= opacity;\n    fragColor = vec4(color, opacity);\n}\n`;\nexport default function MetallicPaint({\n  imageData,\n  params = defaultParams\n}) {\n  _s2();\n  const canvasRef = useRef(null);\n  const [gl, setGl] = useState(null);\n  const [uniforms, setUniforms] = useState({});\n  const totalAnimationTime = useRef(0);\n  const lastRenderTime = useRef(0);\n  function updateUniforms() {\n    if (!gl || !uniforms) return;\n    gl.uniform1f(uniforms.u_edge, params.edge);\n    gl.uniform1f(uniforms.u_patternBlur, params.patternBlur);\n    gl.uniform1f(uniforms.u_time, 0);\n    gl.uniform1f(uniforms.u_patternScale, params.patternScale);\n    gl.uniform1f(uniforms.u_refraction, params.refraction);\n    gl.uniform1f(uniforms.u_liquid, params.liquid);\n  }\n  useEffect(() => {\n    var _s = $RefreshSig$();\n    function initShader() {\n      _s();\n      const canvas = canvasRef.current;\n      const gl = canvas === null || canvas === void 0 ? void 0 : canvas.getContext('webgl2', {\n        antialias: true,\n        alpha: true\n      });\n      if (!canvas || !gl) {\n        return;\n      }\n      function createShader(gl, sourceCode, type) {\n        const shader = gl.createShader(type);\n        if (!shader) {\n          return null;\n        }\n        gl.shaderSource(shader, sourceCode);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n          gl.deleteShader(shader);\n          return null;\n        }\n        return shader;\n      }\n      const vertexShader = createShader(gl, vertexShaderSource, gl.VERTEX_SHADER);\n      const fragmentShader = createShader(gl, liquidFragSource, gl.FRAGMENT_SHADER);\n      const program = gl.createProgram();\n      if (!program || !vertexShader || !fragmentShader) {\n        return;\n      }\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));\n        return null;\n      }\n      function getUniforms(program, gl) {\n        let uniforms = {};\n        let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n        for (let i = 0; i < uniformCount; i++) {\n          var _gl$getActiveUniform;\n          let uniformName = (_gl$getActiveUniform = gl.getActiveUniform(program, i)) === null || _gl$getActiveUniform === void 0 ? void 0 : _gl$getActiveUniform.name;\n          if (!uniformName) continue;\n          uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n        }\n        return uniforms;\n      }\n      const uniforms = getUniforms(program, gl);\n      setUniforms(uniforms);\n      const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\n      const vertexBuffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n      gl.useProgram(program);\n      const positionLocation = gl.getAttribLocation(program, 'a_position');\n      gl.enableVertexAttribArray(positionLocation);\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n      setGl(gl);\n    }\n    _s(initShader, \"ZdQBZ3rq7bWAAMQq6hlVCmYF0jM=\", false, function () {\n      return [gl.useProgram];\n    });\n    initShader();\n    updateUniforms();\n  }, []);\n  useEffect(() => {\n    if (!gl || !uniforms) return;\n    updateUniforms();\n  }, [gl, params, uniforms]);\n  useEffect(() => {\n    if (!gl || !uniforms) return;\n    let renderId;\n    function render(currentTime) {\n      const deltaTime = currentTime - lastRenderTime.current;\n      lastRenderTime.current = currentTime;\n      totalAnimationTime.current += deltaTime * params.speed;\n      gl.uniform1f(uniforms.u_time, totalAnimationTime.current);\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n      renderId = requestAnimationFrame(render);\n    }\n    lastRenderTime.current = performance.now();\n    renderId = requestAnimationFrame(render);\n    return () => {\n      cancelAnimationFrame(renderId);\n    };\n  }, [gl, params.speed]);\n  useEffect(() => {\n    const canvasEl = canvasRef.current;\n    if (!canvasEl || !gl || !uniforms) return;\n    function resizeCanvas() {\n      if (!canvasEl || !gl || !uniforms || !imageData) return;\n      const imgRatio = imageData.width / imageData.height;\n      gl.uniform1f(uniforms.u_img_ratio, imgRatio);\n      const side = 1000;\n      canvasEl.width = side * devicePixelRatio;\n      canvasEl.height = side * devicePixelRatio;\n      gl.viewport(0, 0, canvasEl.height, canvasEl.height);\n      gl.uniform1f(uniforms.u_ratio, 1);\n      gl.uniform1f(uniforms.u_img_ratio, imgRatio);\n    }\n    resizeCanvas();\n    window.addEventListener('resize', resizeCanvas);\n    return () => {\n      window.removeEventListener('resize', resizeCanvas);\n    };\n  }, [gl, uniforms, imageData]);\n  useEffect(() => {\n    if (!gl || !uniforms) return;\n    const existingTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\n    if (existingTexture) {\n      gl.deleteTexture(existingTexture);\n    }\n    const imageTexture = gl.createTexture();\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, imageTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n    try {\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, imageData === null || imageData === void 0 ? void 0 : imageData.width, imageData === null || imageData === void 0 ? void 0 : imageData.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData === null || imageData === void 0 ? void 0 : imageData.data);\n      gl.uniform1i(uniforms.u_image_texture, 0);\n    } catch (e) {\n      console.error('Error uploading texture:', e);\n    }\n    return () => {\n      if (imageTexture) {\n        gl.deleteTexture(imageTexture);\n      }\n    };\n  }, [gl, uniforms, imageData]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    className: \"paint-container\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 545,\n    columnNumber: 10\n  }, this);\n}\n_s2(MetallicPaint, \"8rX5aFPgAMCNMtmiY7MFLSUAiAQ=\");\n_c = MetallicPaint;\nvar _c;\n$RefreshReg$(_c, \"MetallicPaint\");","map":{"version":3,"names":["useEffect","useRef","useState","jsxDEV","_jsxDEV","defaultParams","patternScale","refraction","edge","patternBlur","liquid","speed","parseLogoImage","file","canvas","document","createElement","ctx","getContext","Promise","resolve","reject","Error","img","Image","crossOrigin","onload","type","width","height","MAX_SIZE","MIN_SIZE","naturalWidth","naturalHeight","Math","round","shapeCanvas","shapeCtx","drawImage","shapeImageData","getImageData","data","shapeMask","Array","fill","y","x","idx4","r","g","b","a","inside","boundaryMask","idx","isBoundary","ny","nx","interiorMask","u","Float32Array","newU","C","ITERATIONS","getU","arr","iter","sumN","set","maxVal","i","alpha","outImg","createImageData","px","raw","remapped","pow","gray","putImageData","toBlob","blob","imageData","pngBlob","onerror","src","URL","createObjectURL","vertexShaderSource","liquidFragSource","MetallicPaint","params","_s2","canvasRef","gl","setGl","uniforms","setUniforms","totalAnimationTime","lastRenderTime","updateUniforms","uniform1f","u_edge","u_patternBlur","u_time","u_patternScale","u_refraction","u_liquid","_s","$RefreshSig$","initShader","current","antialias","createShader","sourceCode","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","getUniforms","uniformCount","ACTIVE_UNIFORMS","_gl$getActiveUniform","uniformName","getActiveUniform","name","getUniformLocation","vertices","vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","useProgram","positionLocation","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","renderId","render","currentTime","deltaTime","drawArrays","TRIANGLE_STRIP","requestAnimationFrame","performance","now","cancelAnimationFrame","canvasEl","resizeCanvas","imgRatio","u_img_ratio","side","devicePixelRatio","viewport","u_ratio","window","addEventListener","removeEventListener","existingTexture","getParameter","TEXTURE_BINDING_2D","deleteTexture","imageTexture","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","pixelStorei","UNPACK_ALIGNMENT","texImage2D","RGBA","UNSIGNED_BYTE","uniform1i","u_image_texture","e","ref","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/F1toF/OneDrive/Desktop/cours/cours/cours-project/src/components/MetallicPaint/MetallicPaint.js"],"sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\r\nimport { useEffect, useRef, useState } from 'react';\r\nimport './MetallicPaint.css';\r\n\r\nconst defaultParams = {\r\n  patternScale: 2,\r\n  refraction: 0.015,\r\n  edge: 1,\r\n  patternBlur: 0.005,\r\n  liquid: 0.07,\r\n  speed: 0.3\r\n};\r\n\r\nexport function parseLogoImage(file) {\r\n  const canvas = document.createElement('canvas');\r\n  const ctx = canvas.getContext('2d');\r\n  return new Promise((resolve, reject) => {\r\n    if (!file || !ctx) {\r\n      reject(new Error('Invalid file or context'));\r\n      return;\r\n    }\r\n\r\n    const img = new Image();\r\n    img.crossOrigin = 'anonymous';\r\n    img.onload = function () {\r\n      if (file.type === 'image/svg+xml') {\r\n        img.width = 1000;\r\n        img.height = 1000;\r\n      }\r\n\r\n      const MAX_SIZE = 1000;\r\n      const MIN_SIZE = 500;\r\n      let width = img.naturalWidth;\r\n      let height = img.naturalHeight;\r\n\r\n      if (width > MAX_SIZE || height > MAX_SIZE || width < MIN_SIZE || height < MIN_SIZE) {\r\n        if (width > height) {\r\n          if (width > MAX_SIZE) {\r\n            height = Math.round((height * MAX_SIZE) / width);\r\n            width = MAX_SIZE;\r\n          } else if (width < MIN_SIZE) {\r\n            height = Math.round((height * MIN_SIZE) / width);\r\n            width = MIN_SIZE;\r\n          }\r\n        } else {\r\n          if (height > MAX_SIZE) {\r\n            width = Math.round((width * MAX_SIZE) / height);\r\n            height = MAX_SIZE;\r\n          } else if (height < MIN_SIZE) {\r\n            width = Math.round((width * MIN_SIZE) / height);\r\n            height = MIN_SIZE;\r\n          }\r\n        }\r\n      }\r\n\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n\r\n      const shapeCanvas = document.createElement('canvas');\r\n      shapeCanvas.width = width;\r\n      shapeCanvas.height = height;\r\n      const shapeCtx = shapeCanvas.getContext('2d');\r\n      shapeCtx.drawImage(img, 0, 0, width, height);\r\n\r\n      const shapeImageData = shapeCtx.getImageData(0, 0, width, height);\r\n      const data = shapeImageData.data;\r\n      const shapeMask = new Array(width * height).fill(false);\r\n\r\n      for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n          const idx4 = (y * width + x) * 4;\r\n          const r = data[idx4];\r\n          const g = data[idx4 + 1];\r\n          const b = data[idx4 + 2];\r\n          const a = data[idx4 + 3];\r\n          shapeMask[y * width + x] = !((r === 255 && g === 255 && b === 255 && a === 255) || a === 0);\r\n        }\r\n      }\r\n\r\n      function inside(x, y) {\r\n        if (x < 0 || x >= width || y < 0 || y >= height) return false;\r\n        return shapeMask[y * width + x];\r\n      }\r\n\r\n      const boundaryMask = new Array(width * height).fill(false);\r\n      for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n          const idx = y * width + x;\r\n          if (!shapeMask[idx]) continue;\r\n\r\n          let isBoundary = false;\r\n          for (let ny = y - 1; ny <= y + 1 && !isBoundary; ny++) {\r\n            for (let nx = x - 1; nx <= x + 1 && !isBoundary; nx++) {\r\n              if (!inside(nx, ny)) {\r\n                isBoundary = true;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (isBoundary) {\r\n            boundaryMask[idx] = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      const interiorMask = new Array(width * height).fill(false);\r\n      for (let y = 1; y < height - 1; y++) {\r\n        for (let x = 1; x < width - 1; x++) {\r\n          const idx = y * width + x;\r\n          if (\r\n            shapeMask[idx] &&\r\n            shapeMask[idx - 1] &&\r\n            shapeMask[idx + 1] &&\r\n            shapeMask[idx - width] &&\r\n            shapeMask[idx + width]\r\n          ) {\r\n            interiorMask[idx] = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      const u = new Float32Array(width * height).fill(0);\r\n      const newU = new Float32Array(width * height).fill(0);\r\n      const C = 0.01;\r\n      const ITERATIONS = 300;\r\n\r\n      function getU(x, y, arr) {\r\n        if (x < 0 || x >= width || y < 0 || y >= height) return 0;\r\n        if (!shapeMask[y * width + x]) return 0;\r\n        return arr[y * width + x];\r\n      }\r\n\r\n      for (let iter = 0; iter < ITERATIONS; iter++) {\r\n        for (let y = 0; y < height; y++) {\r\n          for (let x = 0; x < width; x++) {\r\n            const idx = y * width + x;\r\n            if (!shapeMask[idx] || boundaryMask[idx]) {\r\n              newU[idx] = 0;\r\n              continue;\r\n            }\r\n            const sumN = getU(x + 1, y, u) + getU(x - 1, y, u) + getU(x, y + 1, u) + getU(x, y - 1, u);\r\n            newU[idx] = (C + sumN) / 4;\r\n          }\r\n        }\r\n        u.set(newU);\r\n      }\r\n\r\n      let maxVal = 0;\r\n      for (let i = 0; i < width * height; i++) {\r\n        if (u[i] > maxVal) maxVal = u[i];\r\n      }\r\n\r\n      const alpha = 2.0;\r\n      const outImg = ctx.createImageData(width, height);\r\n      for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n          const idx = y * width + x;\r\n          const px = idx * 4;\r\n          if (!shapeMask[idx]) {\r\n            outImg.data[px] = 255;\r\n            outImg.data[px + 1] = 255;\r\n            outImg.data[px + 2] = 255;\r\n            outImg.data[px + 3] = 255;\r\n          } else {\r\n            const raw = u[idx] / maxVal;\r\n            const remapped = Math.pow(raw, alpha);\r\n            const gray = 255 * (1 - remapped);\r\n            outImg.data[px] = gray;\r\n            outImg.data[px + 1] = gray;\r\n            outImg.data[px + 2] = gray;\r\n            outImg.data[px + 3] = 255;\r\n          }\r\n        }\r\n      }\r\n\r\n      ctx.putImageData(outImg, 0, 0);\r\n      canvas.toBlob(blob => {\r\n        if (!blob) {\r\n          reject(new Error('Failed to create PNG blob'));\r\n          return;\r\n        }\r\n        resolve({\r\n          imageData: outImg,\r\n          pngBlob: blob\r\n        });\r\n      }, 'image/png');\r\n    };\r\n\r\n    img.onerror = () => reject(new Error('Failed to load image'));\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n}\r\n\r\nconst vertexShaderSource = `#version 300 es\r\nprecision mediump float;\r\nin vec2 a_position;\r\nout vec2 vUv;\r\nvoid main() {\r\n    vUv = .5 * (a_position + 1.);\r\n    gl_Position = vec4(a_position, 0.0, 1.0);\r\n}`;\r\n\r\nconst liquidFragSource = `#version 300 es\r\nprecision mediump float;\r\nin vec2 vUv;\r\nout vec4 fragColor;\r\nuniform sampler2D u_image_texture;\r\nuniform float u_time;\r\nuniform float u_ratio;\r\nuniform float u_img_ratio;\r\nuniform float u_patternScale;\r\nuniform float u_refraction;\r\nuniform float u_edge;\r\nuniform float u_patternBlur;\r\nuniform float u_liquid;\r\n\r\n#define TWO_PI 6.28318530718\r\n#define PI 3.14159265358979323846\r\n\r\nvec3 mod289(vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec2 mod289(vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec3 permute(vec3 x) { return mod289(((x*34.)+1.)*x); }\r\n\r\nfloat snoise(vec2 v) {\r\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\r\n    vec2 i = floor(v + dot(v, C.yy));\r\n    vec2 x0 = v - i + dot(i, C.xx);\r\n    vec2 i1;\r\n    i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.);\r\n    vec4 x12 = x0.xyxy + C.xxzz;\r\n    x12.xy -= i1;\r\n    i = mod289(i);\r\n    vec3 p = permute(permute(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\r\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\r\n    m = m*m;\r\n    m = m*m;\r\n    vec3 x = 2. * fract(p * C.www) - 1.;\r\n    vec3 h = abs(x) - 0.5;\r\n    vec3 ox = floor(x + 0.5);\r\n    vec3 a0 = x - ox;\r\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\r\n    vec3 g;\r\n    g.x = a0.x * x0.x + h.x * x0.y;\r\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\r\n    return 130. * dot(m, g);\r\n}\r\n\r\nvec2 get_img_uv() {\r\n    vec2 img_uv = vUv;\r\n    img_uv -= .5;\r\n    if (u_ratio > u_img_ratio) {\r\n        img_uv.x = img_uv.x * u_ratio / u_img_ratio;\r\n    } else {\r\n        img_uv.y = img_uv.y * u_img_ratio / u_ratio;\r\n    }\r\n    float scale_factor = 1.;\r\n    img_uv *= scale_factor;\r\n    img_uv += .5;\r\n    img_uv.y = 1. - img_uv.y;\r\n    return img_uv;\r\n}\r\n\r\nvec2 rotate(vec2 uv, float th) {\r\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\r\n}\r\n\r\nfloat get_color_channel(float c1, float c2, float stripe_p, vec3 w, float extra_blur, float b) {\r\n    float ch = c2;\r\n    float border = 0.;\r\n    float blur = u_patternBlur + extra_blur;\r\n    ch = mix(ch, c1, smoothstep(.0, blur, stripe_p));\r\n    border = w[0];\r\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\r\n    b = smoothstep(.2, .8, b);\r\n    border = w[0] + .4 * (1. - b) * w[1];\r\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\r\n    border = w[0] + .5 * (1. - b) * w[1];\r\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\r\n    border = w[0] + w[1];\r\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\r\n    float gradient_t = (stripe_p - w[0] - w[1]) / w[2];\r\n    float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));\r\n    ch = mix(ch, gradient, smoothstep(border - blur, border + blur, stripe_p));\r\n    return ch;\r\n}\r\n\r\nfloat get_img_frame_alpha(vec2 uv, float img_frame_width) {\r\n    float img_frame_alpha = smoothstep(0., img_frame_width, uv.x) * smoothstep(1., 1. - img_frame_width, uv.x);\r\n    img_frame_alpha *= smoothstep(0., img_frame_width, uv.y) * smoothstep(1., 1. - img_frame_width, uv.y);\r\n    return img_frame_alpha;\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = vUv;\r\n    uv.y = 1. - uv.y;\r\n    uv.x *= u_ratio;\r\n    float diagonal = uv.x - uv.y;\r\n    float t = .001 * u_time;\r\n    vec2 img_uv = get_img_uv();\r\n    vec4 img = texture(u_image_texture, img_uv);\r\n    vec3 color = vec3(0.);\r\n    float opacity = 1.;\r\n    vec3 color1 = vec3(.98, 0.98, 1.);\r\n    vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, uv.x + uv.y));\r\n    float edge = img.r;\r\n    vec2 grad_uv = uv;\r\n    grad_uv -= .5;\r\n    float dist = length(grad_uv + vec2(0., .2 * diagonal));\r\n    grad_uv = rotate(grad_uv, (.25 - .2 * diagonal) * PI);\r\n    float bulge = pow(1.8 * dist, 1.2);\r\n    bulge = 1. - bulge;\r\n    bulge *= pow(uv.y, .3);\r\n    float cycle_width = u_patternScale;\r\n    float thin_strip_1_ratio = .12 / cycle_width * (1. - .4 * bulge);\r\n    float thin_strip_2_ratio = .07 / cycle_width * (1. + .4 * bulge);\r\n    float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);\r\n    float thin_strip_1_width = cycle_width * thin_strip_1_ratio;\r\n    float thin_strip_2_width = cycle_width * thin_strip_2_ratio;\r\n    opacity = 1. - smoothstep(.9 - .5 * u_edge, 1. - .5 * u_edge, edge);\r\n    opacity *= get_img_frame_alpha(img_uv, 0.01);\r\n    float noise = snoise(uv - t);\r\n    edge += (1. - edge) * u_liquid * noise;\r\n    float refr = 0.;\r\n    refr += (1. - bulge);\r\n    refr = clamp(refr, 0., 1.);\r\n    float dir = grad_uv.x;\r\n    dir += diagonal;\r\n    dir -= 2. * noise * diagonal * (smoothstep(0., 1., edge) * smoothstep(1., 0., edge));\r\n    bulge *= clamp(pow(uv.y, .1), .3, 1.);\r\n    dir *= (.1 + (1.1 - edge) * bulge);\r\n    dir *= smoothstep(1., .7, edge);\r\n    dir += .18 * (smoothstep(.1, .2, uv.y) * smoothstep(.4, .2, uv.y));\r\n    dir += .03 * (smoothstep(.1, .2, 1. - uv.y) * smoothstep(.4, .2, 1. - uv.y));\r\n    dir *= (.5 + .5 * pow(uv.y, 2.));\r\n    dir *= cycle_width;\r\n    dir -= t;\r\n    float refr_r = refr;\r\n    refr_r += .03 * bulge * noise;\r\n    float refr_b = 1.3 * refr;\r\n    refr_r += 5. * (smoothstep(-.1, .2, uv.y) * smoothstep(.5, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(1., .4, bulge));\r\n    refr_r -= diagonal;\r\n    refr_b += (smoothstep(0., .4, uv.y) * smoothstep(.8, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(.8, .4, bulge));\r\n    refr_b -= .2 * edge;\r\n    refr_r *= u_refraction;\r\n    refr_b *= u_refraction;\r\n    vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);\r\n    w[1] -= .02 * smoothstep(.0, 1., edge + bulge);\r\n    float stripe_r = mod(dir + refr_r, 1.);\r\n    float r = get_color_channel(color1.r, color2.r, stripe_r, w, 0.02 + .03 * u_refraction * bulge, bulge);\r\n    float stripe_g = mod(dir, 1.);\r\n    float g = get_color_channel(color1.g, color2.g, stripe_g, w, 0.01 / (1. - diagonal), bulge);\r\n    float stripe_b = mod(dir - refr_b, 1.);\r\n    float b = get_color_channel(color1.b, color2.b, stripe_b, w, .01, bulge);\r\n    color = vec3(r, g, b);\r\n    color *= opacity;\r\n    fragColor = vec4(color, opacity);\r\n}\r\n`;\r\n\r\nexport default function MetallicPaint({ imageData, params = defaultParams }) {\r\n  const canvasRef = useRef(null);\r\n  const [gl, setGl] = useState(null);\r\n  const [uniforms, setUniforms] = useState({});\r\n  const totalAnimationTime = useRef(0);\r\n  const lastRenderTime = useRef(0);\r\n\r\n  function updateUniforms() {\r\n    if (!gl || !uniforms) return;\r\n    gl.uniform1f(uniforms.u_edge, params.edge);\r\n    gl.uniform1f(uniforms.u_patternBlur, params.patternBlur);\r\n    gl.uniform1f(uniforms.u_time, 0);\r\n    gl.uniform1f(uniforms.u_patternScale, params.patternScale);\r\n    gl.uniform1f(uniforms.u_refraction, params.refraction);\r\n    gl.uniform1f(uniforms.u_liquid, params.liquid);\r\n  }\r\n\r\n  useEffect(() => {\r\n    function initShader() {\r\n      const canvas = canvasRef.current;\r\n      const gl = canvas?.getContext('webgl2', {\r\n        antialias: true,\r\n        alpha: true\r\n      });\r\n\r\n      if (!canvas || !gl) {\r\n        return;\r\n      }\r\n\r\n      function createShader(gl, sourceCode, type) {\r\n        const shader = gl.createShader(type);\r\n        if (!shader) {\r\n          return null;\r\n        }\r\n        gl.shaderSource(shader, sourceCode);\r\n        gl.compileShader(shader);\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n          console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n          gl.deleteShader(shader);\r\n          return null;\r\n        }\r\n        return shader;\r\n      }\r\n\r\n      const vertexShader = createShader(gl, vertexShaderSource, gl.VERTEX_SHADER);\r\n      const fragmentShader = createShader(gl, liquidFragSource, gl.FRAGMENT_SHADER);\r\n      const program = gl.createProgram();\r\n\r\n      if (!program || !vertexShader || !fragmentShader) {\r\n        return;\r\n      }\r\n\r\n      gl.attachShader(program, vertexShader);\r\n      gl.attachShader(program, fragmentShader);\r\n      gl.linkProgram(program);\r\n\r\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n        console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));\r\n        return null;\r\n      }\r\n\r\n      function getUniforms(program, gl) {\r\n        let uniforms = {};\r\n        let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\r\n        for (let i = 0; i < uniformCount; i++) {\r\n          let uniformName = gl.getActiveUniform(program, i)?.name;\r\n          if (!uniformName) continue;\r\n          uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\r\n        }\r\n        return uniforms;\r\n      }\r\n\r\n      const uniforms = getUniforms(program, gl);\r\n      setUniforms(uniforms);\r\n\r\n      const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\r\n      const vertexBuffer = gl.createBuffer();\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n\r\n      gl.useProgram(program);\r\n\r\n      const positionLocation = gl.getAttribLocation(program, 'a_position');\r\n      gl.enableVertexAttribArray(positionLocation);\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n\r\n      setGl(gl);\r\n    }\r\n\r\n    initShader();\r\n    updateUniforms();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (!gl || !uniforms) return;\r\n    updateUniforms();\r\n  }, [gl, params, uniforms]);\r\n\r\n  useEffect(() => {\r\n    if (!gl || !uniforms) return;\r\n\r\n    let renderId;\r\n    function render(currentTime) {\r\n      const deltaTime = currentTime - lastRenderTime.current;\r\n      lastRenderTime.current = currentTime;\r\n      totalAnimationTime.current += deltaTime * params.speed;\r\n      gl.uniform1f(uniforms.u_time, totalAnimationTime.current);\r\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n      renderId = requestAnimationFrame(render);\r\n    }\r\n\r\n    lastRenderTime.current = performance.now();\r\n    renderId = requestAnimationFrame(render);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(renderId);\r\n    };\r\n  }, [gl, params.speed]);\r\n\r\n  useEffect(() => {\r\n    const canvasEl = canvasRef.current;\r\n    if (!canvasEl || !gl || !uniforms) return;\r\n\r\n    function resizeCanvas() {\r\n      if (!canvasEl || !gl || !uniforms || !imageData) return;\r\n      const imgRatio = imageData.width / imageData.height;\r\n      gl.uniform1f(uniforms.u_img_ratio, imgRatio);\r\n      const side = 1000;\r\n      canvasEl.width = side * devicePixelRatio;\r\n      canvasEl.height = side * devicePixelRatio;\r\n      gl.viewport(0, 0, canvasEl.height, canvasEl.height);\r\n      gl.uniform1f(uniforms.u_ratio, 1);\r\n      gl.uniform1f(uniforms.u_img_ratio, imgRatio);\r\n    }\r\n\r\n    resizeCanvas();\r\n    window.addEventListener('resize', resizeCanvas);\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', resizeCanvas);\r\n    };\r\n  }, [gl, uniforms, imageData]);\r\n\r\n  useEffect(() => {\r\n    if (!gl || !uniforms) return;\r\n\r\n    const existingTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\r\n    if (existingTexture) {\r\n      gl.deleteTexture(existingTexture);\r\n    }\r\n\r\n    const imageTexture = gl.createTexture();\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, imageTexture);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n\r\n    try {\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        0,\r\n        gl.RGBA,\r\n        imageData?.width,\r\n        imageData?.height,\r\n        0,\r\n        gl.RGBA,\r\n        gl.UNSIGNED_BYTE,\r\n        imageData?.data\r\n      );\r\n      gl.uniform1i(uniforms.u_image_texture, 0);\r\n    } catch (e) {\r\n      console.error('Error uploading texture:', e);\r\n    }\r\n\r\n    return () => {\r\n      if (imageTexture) {\r\n        gl.deleteTexture(imageTexture);\r\n      }\r\n    };\r\n  }, [gl, uniforms, imageData]);\r\n\r\n  return <canvas ref={canvasRef} className=\"paint-container\" />;\r\n}\r\n\r\n"],"mappings":"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MAAM,CAAC,IAAIC,KAAK,CAAC,sBAAsB,CAAC,CAAC;IAC7DC,GAAG,CAAC8D,GAAG,GAAGC,GAAG,CAACC,eAAe,CAAC1E,IAAI,CAAC;EACrC,CAAC,CAAC;AACJ;AAEA,MAAM2E,kBAAkB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AAEF,MAAMC,gBAAgB,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,eAAe,SAASC,aAAaA,CAAC;EAAER,SAAS;EAAES,MAAM,GAAGtF;AAAc,CAAC,EAAE;EAAAuF,GAAA;EAC3E,MAAMC,SAAS,GAAG5F,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAM,CAAC6F,EAAE,EAAEC,KAAK,CAAC,GAAG7F,QAAQ,CAAC,IAAI,CAAC;EAClC,MAAM,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}